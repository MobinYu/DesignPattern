<html>
	<p>行为型模式 -- 策略模式</p>
	<p>策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。</p>
	<p>通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码</p>

	<p>
		主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
		何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
	</p>

	<p>
		策略模式包含以下几个核心角色：
		环境（Context）：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。
		抽象策略（Abstract Strategy）：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。
		具体策略（Concrete Strategy）：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。
	</p>

	<p>
		示例：专卖店买东西，根据不同客户的vip等级，享受不同的折扣：vip1客户打95折，vip2客户打9折，vip3客户打88折。
		1、不根据用户等级，在用户接口中通过if else方式去获取折扣
		2、根据不同用户等级，建立不同等级的接口，各自实现对应等级的折扣
	</p>

	<p>
		总结：
		策略模式是一个很好的封装各种复杂处理的设计模式，让使用者根据自己的选择来选中策略，而不用修改其他代码。
		当策略太多的时候，可能造成使用方变得复杂、难管理多个策略的问题；解决策略类膨胀的问题，可以考虑使用混合模式（如用工厂方法模式）。
		这其中也是一个见招拆招的问题，设计模式在真正运用中也是这样子的，遇到问题使用恰当的设计模式去解决问题。
	</p>
</html>

